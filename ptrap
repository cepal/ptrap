#!/bin/bash
set -e

# AREAS OF IMPROVEMENTS
# - Monitor other IP protocols (e.g. icmp)
# - Save and restore of tc rules
# - Concurrent execution of multiple istances of this program
# - Detection of packets from already active connections (iptables "-m hashlimit")

PROGRAM_ID_STRING="netportmon"
IPTABLES_RULE_COMMENT="${PROGRAM_ID_STRING}$$"
LOCK_DIRECTORY="/var/run/$PROGRAM_ID_STRING"
TC_DELAY_MS="500"
TAIL_INTERVAL_S="0.1"
IP_TO_MONITOR=""
PORT_TO_MONITOR=""
MONITOR_TCP=""
MONITOR_UDP=""
VERBOSE=""
USER_SCRIPT=""

print_usage () {
cat <<EOF
Usage: $0 { [-h] | [-v] { [-t] | [-u] } -i ip_to_monitor [-p port_to_monitor] [-s delay_ms] [-e path_to_user_script] }

This program uses iptables rules and tc qdisc to find out which process
makes requests to a specific remote IP and port.

IMPORTANT CONSIDERATIONS:
* tc rules currently active will be overwritten, at program start
* only one istance of this script can be executed concurrently
* for TCP port monitoring, only NEW connection are detected
* If too many packets are received, this script might not read them fast
  enough, and some process informations might be lost. If this happens,
  you might want to consider tuning one of these parameters to prevent it
  from happening again, in order of preference:
    1. Increase the delay_ms parameter
    2. If using a user script, optimize its execution time
    3. Edit the TAIL_INTERVAL_S on the top of this script
* The user script is executed synchronously. To not lose any packet, its
  execution time should be kept at minimum.

Parameters:
* -h: print this help message
* -v: be verbose. If unset, only captured process information will be printed out.
* -t: monitor TCP connections
* -u: monitor UDP messages
* -i: remote IP to monitor
* -p: remote PORT to monitor
* -s: delay time for matching packets, in milliseconds. default 500
* -e: path to user script, to execute on packet match. The PID of the
      sending process will be passed to it as parameters.
EOF
}

print_failed_dependency () {
	DEPENDENCY="$1"
	CONTAINING_PACKAGE="$2"
	echo "Failed dependency: the \"$DEPENDENCY\" program must be installed to continue." >&2
	exit -2
}

log () {
	MESSAGE="$1"
	FORCE_LOG="$2"
	PREFIX="[$(date '+%Y-%m-%d, %H:%M:%S.%N')]"
	[ -n "$VERBOSE" -o -n "$FORCE_LOG" ] && echo "$PREFIX $MESSAGE" || true
}


PRG_LSOF="$(which lsof)" || print_failed_dependency "lsof"
PRG_TC="$(which tc)" || print_failed_dependency "tc"
PRG_IPTABLES="$(which iptables)" || print_failed_dependency "iptables"
PRG_IP="$(which ip)" || print_failed_dependency "ip"

while [ $# -gt 0 ]; do
	unset OPTIND
	while getopts "i:p:tuhvs:e:" OPTNAME; do
		case "$OPTNAME" in
			"i") IP_TO_MONITOR="$OPTARG";;
			"p") PORT_TO_MONITOR="$OPTARG";;
			"t") MONITOR_TCP="y";;
			"u") MONITOR_UDP="y";;
			"h") print_usage; exit 0;;
			"v") VERBOSE="y";;
			"s") TC_DELAY_MS="$OPTARG";;
			"e") USER_SCRIPT="$OPTARG";;
			*) log "Error during option parsing. Exiting." force >&2; exit -1
		esac
	done
	shift $((OPTIND-1))

	if [ $# -gt 0 ]; then
		log "Ignoring extra option, \"$1\""
		shift 1
	fi
done

if [ -z "$IP_TO_MONITOR" ]; then
	echo "No target ip defined." >&2
	print_usage
	exit -3
elif [ -z "$MONITOR_TCP" -a -z "$MONITOR_UDP" ]; then
	echo "Select at least one IP protocol to monitor (see options -t and -u)." >&2
	print_usage
	exit -4
fi

PROTOCOLS_TO_MONITOR="${MONITOR_TCP:+tcp} ${MONITOR_UDP:+udp}"
OUTPUT_INTERFACE="$($PRG_IP route get 10.10.41.71 | head -n1 | grep -o -E "dev \w*\s" | cut -d' ' -f2)"
log "Program parameters:"
log "- Ip to monitor: $IP_TO_MONITOR"
log "- Port to monitor: ${PORT_TO_MONITOR:+any}"
log "- Protocols to monitor: $PROTOCOLS_TO_MONITOR"
log "- iptables rule and match identifier: $IPTABLES_RULE_COMMENT"
log "- TC parameters for netem qdisc: delay ${TC_DELAY_MS}"
log "- Output interface: $OUTPUT_INTERFACE (auto detected)"
log "- lsof executable path: $PRG_LSOF"
log "- iptables executable path: $PRG_IPTABLES"
log "- tc executable path: $PRG_TC"
log "- ip executable path: $PRG_IP"
log "- lock directory: $LOCK_DIRECTORY"
log "- User script: ${USER_SCRIPT}"

setup_tc () {
	log "Setting up tc..."
	U32_CMD="$PRG_TC filter add dev $OUTPUT_INTERFACE parent 1:0 protocol ip u32"
	$PRG_TC qdisc del dev "$OUTPUT_INTERFACE" root 2>/dev/null || log "No root qdisc present. Skipping cleanup."
	$PRG_TC qdisc add dev "$OUTPUT_INTERFACE" root handle "1:0" prio bands 4
	$PRG_TC qdisc add dev "$OUTPUT_INTERFACE" parent "1:4" handle "2:0" netem delay "${TC_DELAY_MS}ms"
	[ -n "$MONITOR_UDP" ] && $U32_CMD match ip dst "$IP_TO_MONITOR" match ip protocol 17 FF ${PORT_TO_MONITOR:+match ip dport "$PORT_TO_MONITOR" FFFF} flowid "1:4"
	[ -n "$MONITOR_TCP" ] && $U32_CMD match ip dst "$IP_TO_MONITOR" match ip protocol 6 FF ${PORT_TO_MONITOR:+match ip dport "$PORT_TO_MONITOR" FFFF} flowid "1:4"
	log "tc setup complete.."
}
teardown_tc() {
	log "Tearing down tc..."
	$PRG_TC qdisc del dev "$OUTPUT_INTERFACE" root || log "Error during tc cleanup. Please manually delete tc root qdisc." force >&2
	log "tc teardown complete.".
}

setup_iptables() {
	log "Setting up iptables rules..."
	[ -n "${MONITOR_UDP}" ] && $PRG_IPTABLES -A OUTPUT -p udp -m udp -d "$IP_TO_MONITOR" ${PORT_TO_MONITOR:+--dport "$PORT_TO_MONITOR"} -j LOG --log-prefix "$IPTABLES_RULE_COMMENT" -m comment --comment "$IPTABLES_RULE_COMMENT"
	[ -n "${MONITOR_TCP}" ] && $PRG_IPTABLES -A OUTPUT -p tcp -m tcp --syn -d "$IP_TO_MONITOR" ${PORT_TO_MONITOR:+--dport "$PORT_TO_MONITOR"} -j LOG --log-prefix "$IPTABLES_RULE_COMMENT" -m comment --comment "$IPTABLES_RULE_COMMENT"
	log "iptables rules setup complete."
}
teardown_iptables() {
	log "Tearing down iptables rules..."
	log "Current rules:"
	$PRG_IPTABLES -L OUTPUT --line-numbers | while read LINE; do
		log "$LINE"
	done
	for RULENUMBER in $($PRG_IPTABLES -L OUTPUT --line-numbers | grep "$IPTABLES_RULE_COMMENT" | tac | cut -d' ' -f1 | tr '\n' ' '); do
		log "Deleting rule $RULENUMBER..."
		$PRG_IPTABLES -D OUTPUT $RULENUMBER
	done
	log "iptables rules teardown complete."
}

setup_lock_directory () {
	#IMPROVE also add PID to directory, to allow stale lock check
	log "Creating lock directory..."
	if mkdir "$LOCK_DIRECTORY"; then
		log "Lock directory created successfully."
	else
		log "Error: lock directory already present ad $LOCK_DIRECTORY." force >&2
		log "If another instance is not running, it is stale and can be removed manually with \"rmdir $LOCK_DIRECTORY\"." force >&2
		exit -1
	fi
}

teardown_lock_directory () {
	log "Removing lock directory..."
	rmdir "$LOCK_DIRECTORY"
	log "Lock directory removed successfully."
}

monitor_syslog() {
	log "Starting syslog monitoring..."
	tail -f -s "$TAIL_INTERVAL_S" /var/log/messages | grep --line-buffered "$IPTABLES_RULE_COMMENT" | while read LINE; do
		PROTOCOL=$(echo "$LINE" | grep -o -E "PROTO=\w*" | cut -d= -f2) || PROTOCOL=""
		SOURCE_PORT=$(echo "$LINE" | grep -o -E "SPT=[0-9]+" | cut -d= -f2) || SOURCE_PORT=""
		MATCHING_PID=$($PRG_LSOF -i ${PROTOCOL}:${SOURCE_PORT} | tail -n1 | awk '{print $2}') || MATCHING_PID=""
		if [ -z "$MATCHING_PID" ]; then
			log "ERROR: request detected, but lsof did not list any process. Read the program help for tips on how to avoid this." force >&2
		else
			log "PROCESS REQUEST CAPTURED. Matching PID: $MATCHING_PID" force
			if [ -n "$USER_SCRIPT" ]; then
				USER_SCRIPT_COMMAND="$USER_SCRIPT $MATCHING_PID"
				log "Executing user script: $USER_SCRIPT_COMMAND"
				if bash -c "$USER_SCRIPT_COMMAND"; then
					log "User script executed successfully."
				else
					log "ERROR: user script exited with code $?." forced >&2
				fi
			fi
		fi
	done
}

setup () {
	setup_tc
	setup_iptables
}
teardown () {
	teardown_iptables
	teardown_tc
	teardown_lock_directory
}


setup_lock_directory
trap teardown EXIT
setup
monitor_syslog
