#!/bin/bash
set -e

# AREAS OF IMPROVEMENTS
# - Save and restore of tc rules
# - Concurrent execution of multiple istances of this program
# - Detection of packets from already active connections (iptables "-m hashlimit")

PROGRAM_ID_STRING="netportmon"
IPTABLES_RULE_COMMENT="${PROGRAM_ID_STRING}$$"
LOCK_DIRECTORY="/var/run/$PROGRAM_ID_STRING"
TC_HANDLE="1:"
TC_RATE="20bps"
TC_CEIL="${TC_RATE}"
TC_BURST="1"
TC_CBURST="${TC_BURST}"
IP_TO_MONITOR=""
PORT_TO_MONITOR=""
MONITOR_TCP=""
MONITOR_UDP=""
VERBOSE=""

print_usage () {
	cat <<-EOF
		Usage: $0 { [-h] | [-v] [-t] [-u] -i ip_to_monitor [-p port_to_monitor] }

		This program uses iptables rules and tc qdisc to find out which process
		makes requests to a specific remote IP and port.

		IMPORTANT CONSIDERATIONS:
		* tc rules currently active will be overwritten, at program start
		* only one istance of this script can be executed concurrently
		* for TCP port monitoring, only NEW connection are detected

		Parameters:
		* -h: print this help message
		* -v: be verbose. If unset, only captured process information will be printed out.
		* -t: monitor TCP connections
		* -u: monitor UDP messages
		* -i: remote IP to monitor
		* -p: remote PORT to monitor
	EOF
}

print_failed_dependency () {
	DEPENDENCY="$1"
	CONTAINING_PACKAGE="$2"
	echo "Failed dependency: the \"$DEPENDENCY\" program must be installed to continue." >&2
	exit -2
}

log () {
	MESSAGE="$1"
	FORCE_LOG="$2"
	PREFIX="[$(date '+%Y-%m-%d, %H:%M:%S.%N')]"
	[ -n "$VERBOSE" -o -n "$FORCE_LOG" ] && echo "$PREFIX $MESSAGE" || true
}

PRG_LSOF="$(which lsof)" || print_failed_dependency "lsof"
PRG_TC="$(which tc)" || print_failed_dependency "tc"
PRG_IPTABLES="$(which iptables)" || print_failed_dependency "iptables"
PRG_IP="$(which ip)" || print_failed_dependency "ip"

log "TODO: the tc burst feature prevents the first packet from being slowed down, thus losing it. A \"token bucket drainer\" subprocess will be implemented." force >&2 #TODO implement TBF drainer process

while [ $# -gt 0 ]; do
	unset OPTIND
	while getopts "i:p:tuhv" OPTNAME; do
		case "$OPTNAME" in
			"i") IP_TO_MONITOR="$OPTARG";;
			"p") PORT_TO_MONITOR="$OPTARG";;
			"t") MONITOR_TCP="y";;
			"u") MONITOR_UDP="y";;
			"h") print_usage; exit 0;;
			"v") VERBOSE="y";;
			*) log "Error during option parsing. Exiting." force >&2; exit -1
		esac
	done
	shift $((OPTIND-1))

	if [ $# -gt 0 ]; then
		log "Ignoring extra option, \"$1\""
		shift 1
	fi
done

log "TODO: no sanity check on arguments" force >&2 #TODO arguments sanity checks

PROTOCOLS_TO_MONITOR="${MONITOR_TCP:+tcp} ${MONITOR_UDP:+udp}"
OUTPUT_INTERFACE="$($PRG_IP route get 10.10.41.71 | head -n1 | grep -o -E "dev \w*\s" | cut -d' ' -f2)"
log "Program parameters:"
log "- Ip to monitor: $IP_TO_MONITOR"
log "- Port to monitor: $PORT_TO_MONITOR"
log "- Protocols to monitor: $PROTOCOLS_TO_MONITOR"
log "- iptables rule and match identifier: $IPTABLES_RULE_COMMENT"
log "- TC parameters: rate=${TC_RATE}, ceil="${TC_CEIL}", burst=${TC_BURST}, cburst=${TC_CBURST}"
log "- Output interface: $OUTPUT_INTERFACE (auto detected)"
log "- lsof executable path: $PRG_LSOF"
log "- iptables executable path: $PRG_IPTABLES"
log "- tc executable path: $PRG_TC"
log "- ip executable path: $PRG_IP"
log "- lock directory: $LOCK_DIRECTORY"

setup_tc () {
	log "Setting up tc..."
	$PRG_TC qdisc del dev "$OUTPUT_INTERFACE" root 2>/dev/null || log "No root qdisc present. Skipping cleanup."
	$PRG_TC qdisc add dev "$OUTPUT_INTERFACE" root handle "$TC_HANDLE" htb default 30
	$PRG_TC class add dev "$OUTPUT_INTERFACE" parent "$TC_HANDLE" classid "${TC_HANDLE}1" htb rate $TC_RATE ceil $TC_CEIL burst $TC_BURST cburst $TC_CBURST
	[ -n "$MONITOR_UDP" ] && $PRG_TC filter add dev "$OUTPUT_INTERFACE" parent "$TC_HANDLE" protocol ip u32 match ip dst "$IP_TO_MONITOR" match ip protocol 17 FF match ip dport "$PORT_TO_MONITOR" FFFF flowid "${TC_HANDLE}1"
	[ -n "$MONITOR_TCP" ] && $PRG_TC filter add dev "$OUTPUT_INTERFACE" parent "$TC_HANDLE" protocol ip u32 match ip dst "$IP_TO_MONITOR" match ip protocol 6 FF match ip dport "$PORT_TO_MONITOR" FFFF flowid "${TC_HANDLE}1"
	log "tc setup complete.."
}
teardown_tc() {
	log "Tearing down tc..."
	$PRG_TC qdisc del dev "$OUTPUT_INTERFACE" root handle "$TC_HANDLE" || log "Error during tc cleanup. Please manually delete tc rule." force >&2
	log "tc teardown complete.".
}

setup_iptables() {
	log "Setting up iptables rules..."
	[ -n "${MONITOR_UDP}" ] && $PRG_IPTABLES -v -A OUTPUT -p udp -m udp -d "$IP_TO_MONITOR" --dport "$PORT_TO_MONITOR" -j LOG --log-prefix "$IPTABLES_RULE_COMMENT" -m comment --comment "$IPTABLES_RULE_COMMENT"
	[ -n "${MONITOR_TCP}" ] && $PRG_IPTABLES -v -A OUTPUT -p tcp -m tcp --syn -d "$IP_TO_MONITOR" --dport "$PORT_TO_MONITOR" -j LOG --log-prefix "$IPTABLES_RULE_COMMENT" -m comment --comment "$IPTABLES_RULE_COMMENT"
	log "iptables rules setup complete."
}
teardown_iptables() {
	log "Tearing down iptables rules..."
	log "Current rules:"
	$PRG_IPTABLES -L OUTPUT --line-numbers | while read LINE; do
		log "$LINE"
	done
	for RULENUMBER in $($PRG_IPTABLES -L OUTPUT --line-numbers | grep "$IPTABLES_RULE_COMMENT" | tac | cut -d' ' -f1 | tr '\n' ' '); do
		log "Deleting rule $RULENUMBER..."
		$PRG_IPTABLES -v -D OUTPUT $RULENUMBER
	done
	log "iptables rules teardown complete."
}

setup_lock_directory () {
	#IMPROVE also add PID to directory, to allow stale lock check
	log "Creating lock directory..."
	if mkdir "$LOCK_DIRECTORY"; then
		log "Lock directory created successfully."
	else
		log "Error: lock directory already present ad $LOCK_DIRECTORY." force >&2
		log "If another instance is not running, it is stale and can be removed manually with \"rmdir $LOCK_DIRECTORY\"." force >&2
		exit -1
	fi
}

teardown_lock_directory () {
	log "Removing lock directory..."
	rmdir "$LOCK_DIRECTORY"
	log "Lock directory removed successfully."
}

monitor_syslog() {
	log "Starting syslog monitoring..."
	tail -f -s 0.2 /var/log/messages | grep --line-buffered "$IPTABLES_RULE_COMMENT" | while read LINE; do
		PROTOCOL=$(echo "$LINE" | grep -o -E "PROTO=\w*" | cut -d= -f2) || PROTOCOL=""
		SOURCE_PORT=$(echo "$LINE" | grep -o -E "SPT=[0-9]+" | cut -d= -f2) || SOURCE_PORT=""
		LSOF_OUTPUT=$($PRG_LSOF -i ${PROTOCOL}:${SOURCE_PORT} | tail -n+2) || SS_LINE=""
		if [ -z "$LSOF_OUTPUT" ]; then
			log "ERROR: request detected, but lsof did not list any process. Consider tuning the tc limitation parameters." force >&2
		else
			log "PROCESS FOUND, LSOF_OUTPUT: $LSOF_OUTPUT" force
		fi
	done
}

setup () {
	setup_tc
	setup_iptables
}
teardown () {
	teardown_iptables
	teardown_tc
	teardown_lock_directory
}


setup_lock_directory
trap teardown EXIT
setup
monitor_syslog
